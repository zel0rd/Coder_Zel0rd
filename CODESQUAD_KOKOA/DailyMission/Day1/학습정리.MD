# Day1 학습정리

## 마음가짐 😌
[OT] 코코아 성공적인 학습방법
- 우리는 함께 학습하고 함께 성장한다. 👬
- 온라인으로 적극적으로 질문하고, 답변한다. 🤔🤓
- 내 코드를 부끄럼없이 공유하고, 피드백을 받아 개선한다. 📄
- 코코아는 레벨1이지만 만만치 않다. 그래도 끝까지 도전하자. 💪🏼(해병대 느낌아님...)

## [NODE.JS와 개발환경]
### 프로그래밍 언어와 JavaScript  
####  Compiled vs Interpreted  

- Interpreted Language
> Runtime에 한 번에 한 문장씩 변환  
> 전체 실행시간은 Compiler로 변환한 코드보다 느림  
> 중간 Object Code(목적 코드)가 만들어지지 않아 메모리 효율이 높음  
> 첫 오류를 만날 때까지 프로그램을 계속 번역하고, 오류가 있으면 중지 => 프로그램 실행 전에 오류를 발견하기 어렵다.  
> Python, Ruby와 같은 언어들이 Interpreter를 사용  
- Compiled Language  
> 프로그램 Runtime전에 전체 소스코드를 검사하여 machine code로 변환  
> 소스코드를 분석하는데 많은 시간이 들지만, 전체 실행시간은 상대적으로 빠름  
> 링킹(linking)을 추가로 필요로 하는 중간 Object Code를 생성하여 많은 메모리 필요  
> 전체 코드를 검사한 후에 오류 메시지를 생성, 실행전에 발견  
> C,C++,JAVA와 같은 언어들이 Compiler를 사용  

> Object Code or Object File(목적 코드, 목적 파일) : 컴파일러나 어셈블러가 소스 코드 파일을 이진 코드로 변환하여 생성하는 파일  

> Linking(링킹) :  여러 개의 Object file을 하나의 실행할 수 있는 프로그램으로 만드는 작업  

> https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc
   
### 프로그래밍 패러다임
-  JavaScript는 script언어형태로, 다양한 방식의 프로그래밍 패러다임을 가지는 멀티패러다임 언어

#### 프로그래밍 패러다임이란?
- 프로그래밍 패러다임이란 프로그래머에게 프로그래밍의 관점을 갖게 해주고, 결정하는 역할을 함
- 예를 들어 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있게 하는 반면, 함수형 프로그래밍은 상태값을 지니지 않은 함수값들의 연속으로 생각할 수 있게 함
- 즉, 프로그래밍 패러다임이란 일종의 방법론으로 프로그래밍을 할 때의 어떤 관점에서, 어떤 방향을 지향하는지에 대한 것이라고 생각됨.

#### 프로그래밍언어는 한 개의 패러다임을 갖는가?
- 어떤 언어들은 하나의 특정한 패러다임을 지원하지만, 여러가지 패러다임을 지원하는 언어도 있음
- 객체지향(스몰토크, jdk 1.8 이전의 자바)
- 함수형(하스켈, 스킴)
- 멀티패러다임(파이썬, jdk 1.8 이상의 자바)

#### 언어의 패러다임은 가변적인가?
- 언어의 패러다임은 버전이 올라감에 따라 바뀔 수 있음
- 많은 프로그래밍 패러다임은 어떤 기법을 금지하거나 어떤 것을 가능하게 함

#### 최근 패러다임의 추세는?
- 비교적 새로만들어지는 언어들은 여러 패러다임의 지원을 고려하여 설계 됨  
- 범용성을 강조하는 언어들에서는 최근 함수형, 선언형 패러다임이 적극적으로 적용

#### 패러다임의 종류
##### Imperative(명령형) vs declarative(선언형)
Imperative(명령형)
- 선언형 프로그래밍과 반대되는 개념으로, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명
- 컴퓨터가 수행할 명령들을 순서대로 써놓은 것
- 명령형 프로그래밍의 기본 생각이 개념적으로 친밀하고, 직접적으로 구체화되어 있음

Declarative(선언형)
- 프로그램이 어떤 방법으로 해야하는지를 나태내기보단, 무엇과 같은지를 설명하는 경우에 '선언형'이라고 함
- 예를 들어 웹페이지는 선언형인데, 제목,글꼴,본문,그림과 같이 '무엇'이 나타냐아하는지를 묘사하는 것이지 "어떤" 방법으로 화면을 나타내야 하는지를 묘사하는 것이 아님
- 명령형은 알고리즘을 명시하고 목표를 명시하지 않음
- 선언형은 알고리즘을 명시하지 않고 목표를 명시함

##### Procedural(절차형) vs functional(함수형)
Procedural(절차형)
- 절차지향 혹은 절차지항적 프로그래밍이라고도 불림
- 때때로 명령형 프로그래밍과 동의어로 쓰이지만, 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍 패러다임을 의미하기도 함
- 프로시저는 루틴, 하위프로그램, 서브루틴, 메서드, 함수등과 같고, 수행되어야 할 연속적인 계산 과정을 포함  
// TODO: 프로시저와 모듈성에 대한 공부 필요(스코프)

Functional(함수형)
- 자료 처리를 수학적 함수의 계사느로 취급하고 상태와 가변 데이터를 멀리하는 패러다임
- 명령형 프로그래밍은 상태를 바꾸는 것을 강조하는 것과 달리, 함수형 프로그래밍은 함수의 응용을 강조
- 함수응용과 재귀를 연구하기 위해 개발된 형식 체계인 람다 대수에 근간을 두고 있으며, 람다 연산을 발전시킨 것으로 볼 수 있음
- 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 상태에 따라 다른 결과값이 나올 수 있음
- 반대로 함수형 코드에서는 출력값은 그 함수에 입력된 인수에만 의존  
// TODO : 순수함수에 대한 공부 필요 (순수,익명,고계)

##### 흐름처리 vs 이벤트처리
Event-Driven(이벤트처리)
- 다른 말로 이벤트 구동형 프로그래밍이라고 부름
- 과거에는 프로그램들이 시간의 흐름대로 흘러가는 경향이 있었음
- 하지만 GUI가 대두되면서 흐름을 예측할 수 없게 됨
- 그래서 흐름처리방식에서는 예외처리 방식으로 구현 main함수가 이벤트 발생을 기다림
- 이벤트 처리방식은 이벤트와 이벤트소스로 관점에서 처리
// TODO : 추가정리 필요

##### 클래스기반 vs 프로토타입기반
Class기반
- 클래스기반 언어에서 객체는 일반적으로 두가지 형태가 있음
- '클래스'는 개체의 기본적인 만듦세와 기능 정의
- '인스턴스'는 사용할 수 있는 객체로 특정 클래스의 양식을 기반으로 함
- '클래스'는 동작방식인 메소드의 모임으로 동작하고, 인스턴스의 구조는 동일하고, 인스턴스는 객체의 자료를 가지고 있음

Prototype기반
- Class기반언어에서 상속을 사용하는 것과 달리, 객체를 원형(prototype)으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용
- 클래스리스, 프로토타입 지향, 인스터스기반 프로그래밍이라고도 함
// TODO : 상세분석 필요

### NodeJS
#### NodeJS란
- 서버사이드 자바스크립트이며, 구굴의 자바스크립트 엔진인 V8을 기반으로 구성된 시스템
- Javascript의 runtime, 즉 Javascript program을 실행할 수 있게 해 줌  
>  runtime(런타임)이란?  
> 1. 기존에는 Javascript program을 인터넷 브라우저에서만 실행할 수 있었음  
> 2. 웹 서버에 파일을 업로드할 때, 업로드 진행상황을 알기 위해 서버에 쿼리를 전송  

#### NodeJS의 특징
##### 자바스크립트 런타임
런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻합니다. 따라서 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있다. 쉽게 말해 노드는 자바스크립트 실행기 입니다.

특히, 2008년 구글이 V8 엔진을 사용하여 크롬을 출시하였고, V8엔진은 다른 자바스크립트 엔진과 달리 매우 빨라 라이언 달(Ryan Dahl)은 2009년 V8 엔진 기반의 노드 프로젝트를 시작하며 세상에 나왔습니다.

##### 싱글 스레드
이벤트 기반, 논 블로킹 모델과 더불어 노드를 설명하는 키워드 중 하나는 싱글 스레드 입니다. 자바스크립트 코드는 동시에 실행될 수 없는데 그 이유는 노드가 싱글 스레드 기반이기 때문입니다.

프로세스 : 운영체제에서 할당하는 작업의 단위입니다. 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스입니다. 프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.
스레드 : 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있습니다. 스레드들은 부모 프로세스의 자원을 공유합니다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있습니다.

노드는 싱글스레드, 논 블로킹 모델로, 싱글 스레드가 혼자서 일을 처리하지만 들어온 요청 순서가 아닌 논블로킹 방식으로 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행합니다.

##### 이벤트 기반
노드는 V8과 더불어 libuv라는 라이브러리르 사용합니다. libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있습니다.
이벤트 기반(event-driven)이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미합니다. 즉, 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두고, 이를 이벤트 리스너에 콜백 함수를 등록 합니다. 이후 이벤트가 발생하면 리스너에 등록해둔 콜백 함수를 호출하며 이벤트가 끝난 후 노드는 다음 이벤트가 발생할 때까지 대기합니다.

##### 이벤트 루프
이벤트 루프(event loop)는 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단합니다. 노드는 이벤트가 종료될 때까지 이벤트 처리를 위한 작업을 반복 하므로 루프(loop)라고 부릅니다.

##### 논 블로킹
이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있습니다. 작업에는 두가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업입니다. 특히 파일 시스템 접근, 네트워크를 통한 요청 작업은 I/O의 일종이며 이러한 작업을 할 때 노드는 논 브로킹 방식으로 처리합니다. 논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 의미합니다. 반대로 블로킹은 이전 작업이 끝나야만 다음 작업을 수행합니다.

- 비동기 프로그래밍
- NPM
- Babel

? nodejs를 쓰기 적합한 곳
- 알림이나 실시간 대화같이 같이 데이터의 실시간 처리가 필요한 애플리케이션
- 사용자의 입력과 출력이 잦은 애플리케이션
- 데이터 스트리밍 애플리케이션
- JSON API기반의 애플리케이션
- 단일 페이지 기반의 애플리케이션

? nodejs를 쓰기 적합하지 않은 곳
- data science 같이 복잡한 데이터 처리르 위해 리소스를 많이 쓰는 곳
- 이런 곳에는 python의 django가 적합?

https://dzone.com/articles/nodejs-vs-djangois-javascript-better-than-python

### VSCODE_NodeJS

### VSCODE_NodeJS Debugging

### NodeJS의 Module방식의 프로그래밍

#### Node.js 모듈
- Node.js는 module 단위로 각 기능을 분할할 수 있다. 
- module은 파일과 1대1의 대응 관계를 가지며 하나의 모듈은 자신만의 독립적인 실행 영역(Scope)를 가지게 된다. 
- 따라서 클라이언트 사이드 JavaScript와는 달리 전역변수의 중복 문제가 발생하지 않는다.
- 모듈은 module.exports 또는 exports 객체를 통해 정의하고 외부로 공개한다. 
- 그리고 공개된 모듈은 require 함수를 사용하여 임포트한다.

#### exports
- 모듈은 독립적인 파일 스코프를 갖기 때문에, 모듈 안에 선언한 것들은 해당 모듈 내부에서만 참조가능
- 만약 모듈 안에 선언한 항목을 외부의 다른 모듈이 사용하게 하려면 exports 객체를 사용해야 함
- 모듈을 파일로 작성하고 외부에 공개할 대상을 exports 객체의 프로퍼티 또는 메소드로 정의
- 그리고 모듈을 전역함수 require()를 이용하여 추출  
```javascript
    // circle.js  
    const { PI } = Math;  
    exports.area = (r) => PI * r * r;  
    exports.circumference = (r) => 2 * PI * r;
```

```javascript
    // app.js
    const circle = require('./circle.js'); // require('./circle')

    console.log(`지름이 4인 원의 면적: ${circle.area(4)}`);
    console.log(`지름이 4인 원의 면적: ${circle.circumference(4)}`);
```

#### module.exports
- exports 객체는 프로퍼티 또는 메소드를 여러 개 정의할 수 있음
- 하지만 module.exports에는 하나의 값(원시 타입, 함수, 객체)을 할당할 수 있음

```javascript
    // circle.js
    const { PI } = Math;

    module.exports = functino(r){
        return {
            area() { return PI * r * r; },
            circumference() { return 2 * PI * r }
        }
    }
```
```javascript
    // app.js
    const circle = require('./circle');
    const myCircle = circle(4);

    console.log(`지름이 4인 원의 면적: ${myCircle.area(4)}`);
    console.log(`지름이 4인 원의 면적: ${myCircle.circumference(4)}`);
```
<!-- https://poiemaweb.com/nodejs-module -->

#### require

#### 코어모듈, 파일 모듈


## [자바스크립트 함수]
- 자바스크립트 버전
- 변수 (var, let, const)
- 연산자
- 자바스크립트의 Type
- 비교문, 분기분, 반복문
- for, while 이외의 반복문(forEach, for-of)
- express & statements
- 함수 선언
- 함수 반환값과 undefined
- 함수 arguments속성
- 함수 arrow function
- 함수 native함수들
- 함수 default parameter와 rest parameter
- call by value, call by reference의 차이

## [자바스크립트 디버깅]
https://code.visualstudio.com/docs/editor/debugging
https://www.youtube.com/watch?v=2oFKNL7vYV8&ab_channel=VisualStudioCode
https://developers.google.com/web/tools/chrome-devtools/javascript?hl=ko
- breakpoints란
- watch사용법
- call stack의 의미
- step over / step into / step out


## frontend boilerplate

## npm init / package.json만들기

## git ignore / node_modules

## npm / npx

## CLI Debugger 
https://nodejs.org/api/debugger.html


## 클린코드

## ECMA Script란?
### ES2015 주요문법
- https://www.inflearn.com/course/es6-%EA%B0%95%EC%A2%8C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8

### template literal

1. 왜 var만으로 충분하지 않은지? 왜 const,let을 쓰는가?
scope, 클로저, 호이스팅


## 좋은 코드란?
1. 의도가 코드에서 보여야한다. (변수명, 함수명)


## rest parameters

## style guide
https://github.com/airbnb/javascript#variables--const