## Array
- 자바스크립트에서 리스트형태를 담을 수 있는 자료구조
- 순서가 있는 데이터가 나열

### 자주 사용하는 연산
#### 배열 만들기
```javascript
let fruits = ['사과','바나나']
console.log(fruits.length)
// 2
```

#### 인덱스로 배열의 항목에 접근하기
```javascript
let first = fruits[0]
// 사과

let last = fruits[fruits.length - 1]
// 바나나
```

#### 배열의 항목을 순환하며 처리하기
```javascript
fruits.forEach(function (item, index, array){
    console.log(item, index)
})
// 사과 0
// 바나나 1
```

#### 배열 끝에 항목 추가하기
```javascript
let newLength = fruits.push('오렌지')
// ["사과","바나나","오렌지"]
```

#### 배열 끝에서부터 항목 제거하기
```javascript
let last = fruits.pop() // 끝에 있던 '오렌지'를 제거
// ["사과", "바나나"]
```

#### 배열 앞에서부터 항목 제거하기
```javascript
let first = fruits.shift() // 제일 앞의 '사과'를 제거
// ["바나나"]
```
#### 배열 앞에 항목 추가하기
```javascript
let newLength = fruits.unshift('딸기') // 앞에 '딸기' 추가
// ["딸기", "바나나"]
```
#### 배열 안 항목의 인덱스 찾기
```javascript
fruits.push('망고')
// ["딸기", "바나나", "망고"]

let pos = fruits.indexOf("바나나")
// 1
```
#### 인덱스 위치에 있는 항목 제거하기
```javascript
let removedItem = fruits.splice(pos,1) // 인덱스로 제거
// ["딸기", "망고"]
```

#### 인덱스 위치에서부터 여러개의 항목 제거하기
```javascript
let vegetables = ['양배추', '순무', '무', '당근']
console.log(vegetables)
// ["양배추", "순무", "무", "당근"]

let pos = 1
let n = 2

let removeItems = vegetables.splice(pos, n)
// 배열에서 항목을 제거하는 방법
// pos 인덱스부터 n개의 항목을 제거함

console.log(vegetables)
// ["양배추", "당근"] (원 배열 vegetables의 값이 변함)

console.log(removedItems)
// ["순무", "무"]
```

#### 배열 복사하기
```javascript
let shallowCopy = fruits.slice() // 사본을 만드는 방법
// ["딸기", "망고"]
```

### 배열 요소에 접근하기
```javascript
let arr = ['첫 번재 요소입니다', '두 번째 요소입니다', '마지막 요소입니다']
console.log(arr[0])              
// '첫 번재 요소입니다'를 기록
console.log(arr[1])              
// '두 번재 요소입니다'를 기록
console.log(arr[arr.length - 1]) 
// '마지막 요소입니다'를 기록
```
- 배열 요소에 접근하려면 반드시 괄호 표기법으로 접근해야 함.
- [index], ['index'], ['요소'] / 배열 인덱스도 따옴표로 둘러쌀 수 있지만 굳이 필요하지 않음

```javascript
console.log(years['2'] != years['02']);
// true
```
- years[2]에서 2는 javascript 엔진이 암시적으로 toString으로 변환하기 때문에 '2'와 '02'는 다른 객체를 가르킴

### length와 숫자형 속성의 관계
- JavaScript 배열의 length 속성과 숫자형 속성은 연결되어 있음
- 몇몇 배열 내장 메서드(join, slice, indexOf 등)은 호출했을 때 배열의 length 속성값을 참조
- (push, splice)는 length 속성의 업데이트를 유발함

```javascript
const fruits = []
fruits.psuh('banana','apple','peach')
// [ 'banana', 'apple', 'peach' ]
fruits[5] = 'mango'
// [ 'banana', 'apple', 'peach', <2 empty items>, 'mango' ]
console.log(Object.keys(fruits))
// [ '0', '1', '2', '5' ]
console.log(Object.values(fruits))
// [ 'banana', 'apple', 'peach', 'mango' ]
console.log(fruits.length)
// 6

fruits.pop()
// 'mango'
console.log(fruits)
// [ 'banana', 'apple', 'peach', <2 empty items> ]

fruits.pop()
// undefined
console.log(fruits)
// [ 'banana', 'apple', 'peach', <1 empty item> ]

fruits.length = 3
console.log(fruits)
// [ 'banana', 'apple', 'peach' ]
```

### 매치 결과를 이용한 배열 생성
- 정규표현식과 문자열 사이의 매치 결과로 javaScript배열을 만들 수 있음
- RegExp.exec, String.match, String.replace로부터 배열을 반환받음

```javascript
// 하나의 d와 하나 이상의 b에 하나의 d가 뒤따라 일치해야 합니다.
// 일치한 b와 다음 d를 기억하십시오.
// 대소문자 구분은 무시됩니다.

var myRe = /d(b+)(d)/i;
var myArray = myRe.exec('cdbBdbsbz');
```
-----

### 생성자  

Array()
- Array객체를 생성

### 정적 속성
Array.length
- 값이 1인 Array 생성자의 길이 속성

get Array[@@species]
- 파생 객체를 생성하는데 사용하는 생성자 함수

## 정적 메소드
Array.from()
- 유사 배열 또는 반복 가능한 객체로부터 새로운 Array 인스턴스를 생성

Array.isArray()
- 만약 변수가 배열이면 참, 아니면 거짓을 반환

Array.of()
- 전달인자의 개수나 데이터 타입에 관계없이 새 Array 인스턴스 생성

### Array 인스턴스
- 모든 Array인스턴스는 Array.prototype 상속

? 새로운 메서드와 속성을 추가해 모든 Array를 확장할 수 있으므로, 폴리필에 쓰임  
? 그러나 배열 객체에 비표준 메서드를 추가하면 나중에 스스로, 혹은 JavaScript에 기능이 추가될 경우 문제가 될 수 있음  
? 폴리필(polyfill)은 기본적으로 지원하지 않는 이전 브라우저에서 최신 기능을 제공하는데 필요한 코드를 말함  
- 잘 모를 법한 사실 : Array.prototype은 그 스스로 Array이다.

```javascript
Array.isArray(Array.prototpye) // true
```

### 인스턴스 속성
Array.prototpye.constructor
- 객체의 프로토타입을 생성하는 함수를 지정
Array.prototype.length
- 배열의 원소 수를 나타냄
Array.prototpye([@@unscopables])
- with 결속 범위로부터 제외하려는 속성 이름이 들어있는 기호

### 인스턴스 메서드

#### 변경자 메서드
Array.prototype.copyWithin()
- 배열 내의 지정된 요소들을 동일한 배열 내에서 복사합니다.  

Array.prototype.fill()
- 배열 안의 시작 인덱스부터 끝 인덱스까지의 요소값을 지정된 정적 값으로 채웁니다.  

Array.prototype.pop()
- 배열에서 마지막 요소를 뽑아내고, 그 요소를 반환합니다.  

Array.prototype.push()
- 배열의 끝에 하나 이상의 요소를 추가하고, 변경된 배열의 길이를 반환합니다.  

Array.prototype.reverse()
- 배열의 요소 순서를 반전시킵니다. 첫 번째가 마지막이 되고 마지막이 첫 번째가 됩니다.  

Array.prototype.shift()
- 배열에서 첫 번째 요소를 삭제하고 그 요소를 반환합니다.  

Array.prototype.sort()
- 배열의 요소를 정렬하고 그 배열을 반환합니다.  

Array.prototype.splice()
- 배열에서 요소를 추가/삭제합니다.  

Array.prototype.unshift()
- 배열의 앞에 하나 이상의 요소를 추가하고 새로운 길이를 반환합니다.  

#### 접근자 메서드
Array.prototype.concat()
- 배열을 매개변수로 주어진 배열/값과 이어붙인 새로운 배열을 반환합니다.  

Array.prototype.filter()
- 지정한 콜백의 반환 결과가 true인 요소만 모은 새로운 배열을 반환합니다.  

Array.prototype.includes()
- 배열이 주어진 값을 포함하는지 판별해 true 또는 false를 반환합니다.  

Array.prototype.indexOf()
- 배열에서 주어진 값과 일치하는 제일 앞의 인덱스를 반환합니다. 없으면 -1을 반환합니다.  

Array.prototype.join()
- 배열의 모든 요소를 문자열로 합칩니다.  

Array.prototype.lastIndexOf()
- 배열에서 주어진 값과 일치하는 제일 뒤의 인덱스를 반환합니다. 없으면 -1을 반환합니다.  

Array.prototype.slice()  
- 배열의 일부를 추출한 새 배열을 반환합니다.  

Array.prototype.toSource() 
- 지정한 배열을 나타내는 배열 리터럴을 반환합니다. 새로운 배열을 만들기 위해 이 값을 사용할 수 있습니다. Object.prototype.toSource() 메서드를 재정의합니다.   

Array.prototype.toString()
- 배열과 그 요소를 나타내는 문자열을 반환합니다. Object.prototype.toString() 메서드를 재정의합니다.  

Array.prototype.toLocaleString()
- 배열과 그 요소를 나타내는 지역화된 문자열을 반환합니다. Object.prototype.toLocaleString() 메서드를 재정의합니다.  

#### 순회 메서드
Array.prototype.entries()

- 배열의 각 인덱스에 대한 키/값 쌍을 포함하는 새로운 배열 반복자 객체를 반환합니다.  

Array.prototype.every()
- 배열의 모든 요소가 주어진 판별 콜백을 만족할 경우 true를 반환합니다.  

Array.prototype.find()
- 주어진 판별 콜백을 만족하는 첫 번째 요소를 반환합니다. 만족하는 요소가 없으면 undefined를 반환합니다.  

Array.prototype.findIndex()
- 주어진 판별 콜백을 만족하는 첫 번째 요소의 인덱스를 반환합니다. 만족하는 요소가 없으면 undefined를 반환합니다.  

- Array.prototype.forEach()
배열의 각각의 요소에 대해 콜백을 호출합니다.  

- Array.prototype.keys()

배열의 각 인덱스에 대한 키를 가지는 새로운 배열 반복자 객체를 반환합니다.  

- Array.prototype.map()
배열의 모든 요소 각각에 대하여 주어진 콜백 함수를 호출하고, 그 반환값을 모은 새로운 배열을 반환합니다.  

- Array.prototype.reduce()
주어진 콜백 함수를 가산기와 요소 각각에 대해 왼쪽에서 오른쪽으로 호출하여 하나의 값으로 줄인(reduce) 결과를 반환합니다.  

Array.prototype.reduceRight()
- 주어진 콜백 함수를 가산기와 요소 각각에 대해 오른쪽에서 왼쪽으로 호출하여 하나의 값으로 줄인(reduce) 결과를 반환합니다.  

Array.prototype.some()
- 배열의 어떤 요소가 주어진 판별 콜백을 만족할 경우 true를 반환합니다.  

Array.prototype.values()
- 배열의 각 인덱스에 대한 값을 가지는 새로운 배열 반복자 객체를 반환합니다.  

Array.prototype[@@iterator]()
- 배열의 각 인덱스에 대한 값을 가지는 새로운 배열 반복자 객체를 반환합니다.  

------

### 배열의 메서드
- forEach / map / filter / immutable

#### for vs forEach
```javascript
var data = [ {title : "hello", content : "간지철철", price : 12000},
             {title : "crong", content : "괜춘상품", price : 5500},
             {title : "codesquad", content : "쩌는상품", price : 1200}]

// for문
for(var i=0; i <data.length; i ++){
    console.log(data[i].title, data[i].price);
};

// forEach문
data.forEach(function(v){
    console.log(v.title, v.price);
});

// forEach의 원리
function printElement(v) {
    console.log(v.title, v.price);
}

data.forEach(printElement)
```

#### map vs filter
- map으로 간단하게 새로운 객체을 만들 수 있음
```javascript
var newData = data.map(function(v) {
    return v.price * 1.1;
});
// newData = [ 13200.000000000002, 6050.000000000001, 132 ]
```

```javascript
var newData = data.map(function(v) {
    var obj = {name : v.title, content: v.content, price : v.price*10}
    return obj;
})
console.table(newData)
```

- filter를 사용하여 특정 조건으로만 객체를 만듦
```javascript
var newData = data.filter(function(v) {
    return v.price > 5000
})
console.table(newData)
```

```javascript
var newData = data.filter(function(v) {
    return v.price > 5000
}).map(function(v) {
    var obj = {title : v.title, content: v.content, price : v.price+""};
    return obj;
})
console.table(newData)
```

#### reduce
#### some / every


https://www.daleseo.com/js-module-require/





------

## 객체(Object)
- 순서가 있는 리스트는 배열
- 객체는 순서는 없지만 key,value의 형태의 자료
- 객체 형태는 {}로 그 자료를 표현하며, 서버와 클라이언트 간의 데이터를 교환할 때도 객체형태와 비슷한 방법으로 전송

 https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Working_with_Objects#객체_생성하기

### 객체 선언
```javascript
var obj = { name : "crong", age : 20}
```

```javascript
var myFriend = {key: "value"};
console.log(myFriend.key) // value
// console.log(myFriend[key]) // error
console.log(myFriend['key'])  // value
```

```javascript
var myFriend = {key: "value", addition : [
    {name:'codesquad'},{age:2}
]};
console.log(myFriend.addition[0].name)  // codesquad
console.log(myFriend.addition[0]['name'])  // codesquad
```

### 객체의 탐색
- for-in 구문을 사용하는 것이 대표적
    - for-in문은 key값이 있는 object를 탐색하기 위해서 사용
    - 배열에서는 for-in문을 권장하지 않음
```javascript
// for-in
var myFriend = {
    key: "value", 
    addition : [
        {name:'codesquad'},{age:2}
    ]
};

for(key in myFriend) {
    console.log(myFriend[key])
}
// value
// [ { name: 'codesquad' }, { age: 2 } ]
```

```javascript
Object.keys(myFriend);
// [ 'key', 'addition' ]

Object.keys(myFriend).forEach(function(v) {
    console.log(myFriend[v]);
});
// value
// [ { name: 'codesquad' }, { age: 2 } ]
```
------

## 자바스크립트가 정확한 값을 계산하기 어려운 이유

## object 하위 노드 호출하는법?

## reduce 만들기

## JavaScript set & map

## 체크포인트
- 고차함수가 무엇인가
- for,while문을 사용하지 않고 배열을 iteration
- reduce 메서드를 직접 작성
- JavaScript 객체를 iteration하고 객체의 속성에 접근해서 추가/변경할 수 있다.

## class 생성방법
- class / contructor /
- 생성자 패턴 (function을 new로 호출할 때,)
    - method를 각각 같기 때문에, 메모리가 낭비됨 (단점)
- prototype
    - 생성자패턴의 메모리사용의 단점을 극복하기 위해 prototype 이라는 속성의 키워드를 사용해서 객체를 생성하는 것이 JS 객체를 생성하는 표준적인 방법
    - 그런데 표현법이 너무 번거롭기 때문에, ES 2015에서는 ES Classes라는 표준으로 Class키워드를 만들어서 OOP처럼 클래스를 좀 더 직관적으로 사용할 수 있게 했다.



## 설계
- 설계는 무엇인가?
- 패턴 찾기
- 설계 9 : 코딩 1
- code and fix VS design and code

## 1급 객체 (first class citizen)

## mutable vs immutable

## array.from 사용법 알기

## spread operator

## reduce 꼭 알기

## arrow function

## prototype
require('파일 경로');


## js파일에서 변수 불러오기

```javascript
// modules.js
let name = 'foobar';
let city = 'xyz';
let company = 'companyName';

module.exports = {
    name,
    city,
    company
}
```

```javascript
// main.js
let data = require('./modules');

console.log(data)
```